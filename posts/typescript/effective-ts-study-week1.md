---
title: 이펙티브 타입스크립트 (아이템1 ~ 아이템8) 정리
description: 이펙티브 타입스크립트 스터디를 진행하며 공부한 내용 정리
category: Typescript
date: 2022-04-17
---

## 아이템 1: 타입스크립트와 자바스크립트의 관계 이해하기

타입스크립트는 문법적으로 자바스크립트의 상위 집합입니다.
문법 상의 오류가 있어도 타입스크립트는 여전히 작성된 코드를 파싱하고 자바스크립트로 변환할 수 있습니다.

> 나의 생각 - 어디까지 문법 상의 오류를 봐주는 거지?

> 결론: 아예 틀려먹은 코드를 짜도 변환은 된다.

![아예 틀린코드](https://i.imgur.com/hJlbOhV.png)

타입스크립트는 초기값으로 부터 타입을 추론합니다.

타입스크립트를 쓰는 이유는 런타임에 오류를 발생시킬 코드를 미리 찾아내기 위해서 입니다.

```tsx
const states = [
  { getName: () => "A" },
  { getName: () => "B" },
  { getName: () => "C" },
  { getName: () => "D" },
];

for (const state of states) {
  console.log(state.getNeme()); // 타입에서 에러가 발생. 런타임에서 에러 방지 가능
}
```

하지만 타입 체커를 통과했다고 해서 런타임 오류가 발생하지 않는 것은 아닙니다.

타입 체커를 통과했지만 런타임 오류를 발생시키는 코드는 충분히 존재할 수 있습니다.

> 예시

```tsx
const response: { a: number } = await fetchFromApi();

response.a;
// 만약에 Api에서 a를 내려주지 않는다면
// 타입 체커는 통과하지만
// 런타임에서 에러가 발생한다.
```

## 아이템 2: 타입스크립트 설정 이해하기

타입스크립트는 여러 설정으로 사용할 수 있습니다.

단순한 설정과 다른 언어 자체의 핵심을 바꾸는 핵심적인 설정도 존재하는데,

`noImplicitAny`와 `strictNullChecks`와 같은 설정입니다..

`noImplicitAny`는 직역하자면 암묵적인 any 거절이다. 이는 변수들이 미리 정의된 타입을 가져야 하는지에 대한 여부를 체크합니다.

```tsx
// noImplicitAny가 참일 때에는 이 코드는 타입 에러를 낸다.
// noImplicitAny가 거짓일 때는 이 코드는 타입 에러를 내지 않는다.
function add(a, b) {
  return a + b;
}
```

`noImplicitAny` 가 true일 때에는 타입을 명시하지 않으면 에러를 낸다.  
타입을 명시하지 않으면 암묵적으로 `any`를 타입으로 달아주는데, `noImplicitAny`를 사용하면 이 암묵적인 설정을 사용하지 않고, 타입을 명시해 주지 않으면 에러를 내겠다는 것입니다.

타입스크립트는 `any`를 사용하게 되면 타입 추론이 무력해지기 때문에, 최대한 any를 사용하지 않는 것이 좋습니다.

따라서 any를 최대한 쓰지 않고 타입 정보를 최대한 명시하기 위해 `noImplicitAny`를 true로 설정하는 것이 좋습니다.

`noImplicitAny` 설정 해제는, JS로 되어있는 코드를 TS로 마이그레이션 할 때에만 필요합니다.

`strictNullCheck`는 null과 undefined가 모든 타입에서 허용되는지 확인하는 설정입니다.

```tsx
// StrictNullCheck가 참일때에는 이 코드는 타입 에러를 낸다.
// StrictNullCheck가 거짓일때에는 이 코드는 타입 에러를 내지 않는다.

const x: number = null;
```

이 설정을 키게 되면 “undefined”는 객체가 아닙니다 같은 에러를 많이 줄일 수 있게 됩니다.

```tsx
const el = document.querySelector("#id"); // 이 el은 null이 될수도 있다.
// id 라는 아이디를 가진 엘리먼트가 없을 수도 있기 때문이다.
// 하지만 strictNullCheck를 끄게 되면 null 체크를 약하게 하기 때문에

el.textContext = "";
// 의 코드에서 에러를 내지 않는다.
```

### 아이템 3: 코드 생성과 타입이 관계 없음을 이해하기

타입스크립트 컴파일러는 두가지의 역할을 수행합니다.
첫째, TS 코드를 JS로 트랜스컴파일 하는 역할을 수행합니다.  
둘째, 코드의 타입 오류를 체크하는 역할을 수행합니다.

하지만 이 두개가 완벽하게 독립적이라는 것입니다.  
트랜스파일 할때 코드의 타입 오류를 체크하지 않습니다.

위의 예시에서 보았듯이 (아이템1), 타입 오류가 있는 코드도 컴파일이 가능합니다.

타입 오류가 컴파일이 되는게 좋을 때가 존재하는데, 특정 부분에 문제가 있더라도 그 부분 외의 다른 부분은 테스트를 할 수 있다는 점에서 좋습니다.

만약에 타입이 틀린 코드를 트랜스컴파일 하지 않으려면, `noEmitOnError` 속성을 켜주거나 빌드 도구에 동일하게 적용해주면 됩니다.

**런타임에는 타입 체크가 불가능합니다**
왜냐하면 트랜스파일되면서 타입 정보가 다 날라가기 때문입니다.  
따라서, 타입 정보를 런타임에 유지하는 방법이 필요할 때가 존재하는데, 이때에는
`in` 키워드를 사용해 체크하는 방법과 `태그 기법`이 있습니다.

`태그 기법`은 타입 정보를 객체에 유지하는 것입니다.

```tsx
interface Square {
  kind: "square";
}

interface Rectangle {
  kind: "rectangle";
}

type Shape = Square | Rectangle;

// 이렇게 되면 런타임에 손쉽게 타입 정보를 유지할수 있게 됨.
```

> **내 생각**
>
> 이게 과연 좋은 방법일까?  
> 타입체크만을 위해 속성에 타입을 추가하는 것이 좋지 않을수도 있다고 생각합니다.  
> 왜냐하면 타입체크만을 위해 필요없는 프로퍼티가 하나 더 생기는 거기에 로직이 오염될 가능성이 존재한다고 생각합니다.

또 다른 방법으로는 타입과 값을 동시에 쓰는 방법이 있습니다.

클래스를 활용하면 되는데요,

타입을 클래스로 만들어버리면 타입과 값 모두로 사용할 수 있습니다.

```tsx
type Shape = Rectangle | Square;
```

이때는 Rectangle과 Square이 타입으로 참조되지만

```tsx
if (shape instanceof Rectangle)
```

을 하게 되면 값으로 참조됩니다.

**타입 연산은 런타임에 영향을 주지 않는다**

당연한 이야기입니다.  
런타임에는 타입이 다 날라간 트랜스컴파일된 자바스크립트로 돌아가는데, 타입 연산이 런타임에 영향을 줄 수가 없습니다.

**타입스크립트 타입으로는 함수를 오버로드 할 수 없습니다.**

타입스크립트에는 타입과 런타임의 동작이 무관하기 때문에 함수 오버로딩이 불가능합니다.

```tsx
function add(a: number, b: number): number;
function add(a: string, b: string): number;
```

이거는 타입스크립트에서 함수를 오버로딩하는 예시입니다. 이 예시는 타입에서의 정의이지 런타임에서의 구현체는 하나가 트랜스컴파일되면서 다 날라가게 됩니다.

결론적으로 런타임되면 타입이 다 날라가게 됩니다.

## 아이템 4: 구조적 타이핑에 익숙해지기

타입스크립트는 객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우에 객체를 해당 타입에 속하는 것으로 간주합니다.

이를 구조적 타이핑이라고 합니다.

```tsx
interface Vector2D {
  x: number;
  y: number;
}
```

라는 인터페이스가 있다고 가정해봅시다. 그리고 벡터의 거리를 구하는 함수가 있다고 해봅시다.

```tsx
function calcLength(vec: Vector2D) {
  return Math.sqrt(v.x * v.x + v.y + v.y);
}
```

이제 이름 프로퍼티가 있는 타입을 선언해봅시다.

```tsx
interface NamedVector {
  name: string;
  x: number;
  y: number;
}
```

그리고 아래와 같이 사용했을 때,

```tsx
const v: NamedVector = { x: 3, y: 4, name: "moai" };
calcLength(v); // 타입 에러가 나지 않음
```

`calcLength(v)`에서 타입 에러가 나지 않습니다.

이유는 `NamedVector`에 `x`, `y` 속성이 있기 때문에 `Vector2D`에 할당할 수 있다고 판단한 것입니다. 구조가 호환됩니다.

이 맥락에서 `구조적 타이핑`이라는 워딩이 나오는 것입니다.

타입스크립트는 특정 속성만 만족한다면 타입이 호환됩니다.

이러한 특징 때문에 아래와 같은 에러가 발생합니다.

```tsx
function calculateLength(v: Vector3D) {
  let length = 0;

  for (const axios of OBject.keys(v)) {
    const coord = v[axis]; // 에러: string은 Vector3D의 인덱스로 사용할 수 없기에....
    length += Math.abs(coord);
  }
  return length;
}
```

에러가 발생하는 이유는 만약 vector3D의 속성을 만족하는 객체가 다른 attribute를 가질수 있기 때문입니다. 구조적 타이핑이기 때문입니다.

따라서 string은 vector3D의 인덱스로 사용할수 없다는 에러가 발생합니다.

구조적 타이핑은 유닛테스트에 용이합니다.

인터페이스를 최소화해서 실제 구현과 다른 인터페이스만 만족하는 다른 Mock 객체 같은 것을 만들어서 활용이 가능하기 때문입니다.

## 아이템 5: any 타입 지양하기

TS의 타입은 코드에 타입을 조금씩 추가할 수 있기 때문에 점진적이고 선택적입니다.

언제든지 선택적으로 타입 체커 해제가 가능합니다.

any를 쓰는 이유는 보통 “귀찮아서" 인데, 이렇게 하면 여러가지 단점들이 생기게 됩니다.

**any를 쓰게 되면 타입 안정성이 사라진다**

```tsx
let age: any = "12";
age += 1;
```

**any는 함수 시그니처를 무시해 버립니다.
함수 파라미터에 넣으면 안되는 값까지 넣을수 있게 됩니다**

```tsx
function calculateAge(birthDate: Date): number {
  // ....
}

const bd: any = "1313";
calculateAge(bd); // 에러를 내지 않음.
```

**any는 언어 서비스가 적용되지 않습니다**

any를 사용하면 자동완성이 되지 않습니다.

**any 타입은 리팩터링때 버그를 감추게 됩니다**

특정한 타입을 설정하지 않으면, 리팩터링 했을 때 타입에서 에러가 발생합니다.

**any는 타입 설계를 감춰버립니다.**

any를 사용하게되면 해당하는 객체가 어떻게 생긴 친구인지 전혀 가늠이 안가서
직접 흐름을 추론해서 파악해야 합니다.

**any는 타입시스템의 신뢰도를 떨어트립니다.**

any가 많아지면, 타입 추론이 되지 않아 이 타입이 맞는지에 대한 신뢰가 떨어지게 됩니다.

> ### 한줄요약
>
> any는 타입 추론이 잘 안되니깐 최대한 쓰지 말자.

## 아이템 6: 편집기를 사용하여 타입 시스템 탐색하기

타입스크립트는 두가지를 제공합니다.

1. 컴파일러
2. 언어 서버

언어 서비스를 제공하기 때문에 IDE를 사용하는 것이 유리합니다.

또한, 타입스크립트 선언 파일 (`d.ts`) 를 찾아보면 타입 공부하는데, 라이브러리를 이해하는데에 큰 도움이 됩니다.

## 아이템 7: 타입이 값들의 집합이라고 생각하기

`할당 가능한 값들의 집합`이 타입이라고 생각하면 편합니다.

예를 들어, 모든 숫자값의 집합을 `Number` 타입이라고 생각할수도 있습니다.

가장 작은 집합은 공집합이며, `never` 타입입니다.

이 타입에는 아무 것도 할당할 수 없습니다

```tsx
const x: never = 3; // 에러
```

그 다음으로 작은 집합은 한가지 값만 포함하는 리터럴 입니다.

```tsx
type A = "A";
type B = "B";
```

두개 혹은 세개로 묶으려면 유니온 타입 사용하면 됩니다.

```tsx
type ABC = "A" | "B" | "C";
```

유니온 타입은 합집합을 의미합니다.

할당 가능하다는 말은 부분집합에 타입이 해당하는 타입의 부분 집합이라는 것을 의미합니다.

```tsx
const a: AB = "A"; // 'A' 는 {'A', 'B'}의 원소
const c: AB = "C"; // "C" 형식은 'AB' 형식에 할당 불가능
```

타입 체크는 부분집합인지를 검사하는 것이라고 생각해도 편합니다.

& 연산자는 두 타입의 교집합을 계산하는 것입니다.

```tsx
interface A {
  name: string;
}

interface B {
  birth: Date;
  death?: Date;
}

type Intersection = A & B;
```

근데 교집합이라면 두개 프로퍼티 겹치는게 없어 `never`이 되야하는데, 왜 추론은

```tsx
type Intersection = {
  name: string;
  birth: Date;
  date?: Date;
};
```

로 되는 것일까요?

이유는 타입 연산자는 인터페이스의 속성이 아닌 타입의 범위로 계산되기 때문입니다.

`A`: `name` 을 가지기만 하면 되는 타입  
`B`: `birth`, `death`를 가지기만 하면 되는 타입

이 타입들의 교집합은
`name`, `birth`, `death`를 가지기만 하면 되는 타입이기에 타입 추론으로
`name`, `birth`, `death`를 추론할 수 있게 됩니다.

| 연산자는 두 타입의 합집합 입니다.

`A`: `name` 을 가지기만 하면 되는 타입  
`B`: `birth`, `death`를 가지기만 하면 되는 타입

이 두 타입의 합집합은

`name` 을 가지기만 하면 되는 타입 + `birth`, `death`를 가지기만 하면 되는 타입 입니다.

근데 이렇게 되면 타입 추론이 되지 않습니다.

`name` 을 가지기만 하면 되는 타입에서 추론할수 있는 프로퍼티는 `name` 뿐입니다.

`birth`, `death` 를 다 가지기만 하면 되는 타입에서 추론할 수 있는 프로퍼티는 `birth`, `death` 입니다.

이 두개를 포괄하는 타입에서 추론할수 있는 프로퍼티는 **없습니다**.

따라서 겹치는 프로퍼티가 없는 두 타입의 유니온 타입은 프로퍼티가 추론이 되지 않습니다.

`<T extends string>` T의 타입이 string의 부분집합이기만 하면 되는 타입이라는 것입니다.

결론적으로는 **타입 연산은 집합의 범위에 해당합니다.**

## 아이템8 타입공간과 값 공간의 심벌 구분하기

심벌은 타입공간이나 값 공간 중 한 곳에 존재합니다.

심벌은 이름이 같더라도, 속하는 공간에 따라 다른 것을 나타낼 수 있기 때문에 혼란스러울 수 있습니다.

```tsx
interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius: number, height: number) => ({ radius, height });
```

interface는 타입으로 쓰이고,
`const Cylinder`는 값으로 쓰입니다.

이름은 같지만 서로 다른 공간에 존재하기 때문에 아무런 관련이 없습니다.

따라서 Cylinder은 값과 타입 모두로 쓰일수가 있습니다.

```tsx
function calculateVolume(shape: unknown) {
  if (shpae instanceof Cylinder) {
    shape.radius; /// {} 형식에 radius가 없다
  }
}
```

`instanceof` 를 이용해 `Cylinder`의 타입인지를 체크하려 의도했겠지만 `instanceof` 는 값 연산자이기에 함수를 참조합니다. 따라서 타입에러가 발생합니다.

클래스와 enum은 타입이 될수도 있고 값이 될수도 있습니다.

클래스가 타입으로 쓰일때에는 타입의 형태 (메서드나 프로퍼티)가 사용되는 반면, 값으로 쓰일때는 생성자가 사용됩니다.

연산자 중에서 `typeof`는 타입에서 쓰일때랑 값에서 쓰일때 다른 기능을 합니다.

```tsx
type T1 = typeof p; // p의 타입 추론
type T2 = typeof email; // email의 타입 추론

const v1 = typeof p; // 값은 "object"
const v2 = typeof email; // 값은 "function"
```

`typeof` 연산자는 타입으로 쓰일때에는 타입을 반환합니다.

값의 관점에서는 자바스크립트의 `typeof` 런타임 연산자가 됩니다.

값으로 쓰이는 `this`는 자바스크립트의 this 키워드입니다.

타입으로 쓰이는 `this`는 클래스의 타입이 됩니다.

`&`, `|` 값으로 쓰이면 비트 연산자, 타입으로 쓰이면 인터섹션, 유니온 타입이 됩니다.

`as const`는 리터럴 또는 리터럴 표현식의 추론 타입을 변경하는 타입 연산자입니다.

`extends`는 서브 클래스 (`class A extends B`) , 서브 타입 (`interface A extends B`), 또는 제네릭 타입의 한정자 (`<T extends string>`) 로 사용될 수 있습니다.

`in`은 루프 혹은 `맵드 타입`에 사용될 수 있습니다.
